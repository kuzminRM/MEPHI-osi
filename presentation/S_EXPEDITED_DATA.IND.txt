;параметры:  userdata (буфер)
out CurrentSystemName() " s expedited data ind __start"

; достаем entityNum
userdata unbufferit entityNum 1 dataReceived sizeof(userdata)-1

; определяем какой запрос пришел
$entityNum == 1 if context_req_tag
$entityNum == 2 if context_resp_tag
$entityNum == 3 if context_from_conf_tag
$entityNum == 4 if original_data_tag

return

context_req_tag:
out "requested context"
; отправляем сохраненный contextFromConnectResp
dataToSend pack 2 1 $contextFromConnectResp sizeof(contextFromConnectResp) sizeof(contextFromConnectResp)+1
userdata $dataToSend eventdown S_EXPEDITED_DATA.REQ
return

context_resp_tag:
out "context delivered"
$dataReceived  setto contextFromConnectResp

; получаем какие синтаксисы передачи данных разрешены у нас
sizeof(contextFromConnectReq) != 4 if skip_if_context_11_tag
1 setto isOurSyntaxLenEnabled
1 setto isOurSyntaxEndSymbolEnabled
skip_if_context_11_tag:
sizeof(contextFromConnectReq) != 3 if skip_if_context_12_tag
contextFromConnectReq unbufferit temp 2 syntaxNumTemp 1
$syntaxNumTemp == 1 if skip_if_context_13_tag
1 setto isOurSyntaxLenEnabled
0 setto isOurSyntaxEndSymbolEnabled
skip_if_context_13_tag:
$syntaxNumTemp == 2 if skip_if_context_14_tag
0 setto isOurSyntaxLenEnabled
1 setto isOurSyntaxEndSymbolEnabled
skip_if_context_14_tag:
skip_if_context_12_tag:
out "our Len = " $isOurSyntaxLenEnabled " EndSymb " $isOurSyntaxEndSymbolEnabled

; получаем какие синтаксисы передачи данных разрешены у них
sizeof(contextFromConnectResp) != 4 if skip_if_context_21_tag
1 setto isTheirSyntaxLenEnabled
1 setto isTheirSyntaxEndSymbolEnabled
skip_if_context_21_tag:
sizeof(contextFromConnectResp) != 3 if skip_if_context_22_tag
contextFromConnectResp unbufferit temp 2 syntaxNumTemp 1
$syntaxNumTemp == 1 if skip_if_context_23_tag
1 setto isTheirSyntaxLenEnabled
0 setto isTheirSyntaxEndSymbolEnabled
skip_if_context_23_tag:
$syntaxNumTemp == 2 if skip_if_context_24_tag
0 setto isTheirSyntaxLenEnabled
1 setto isTheirSyntaxEndSymbolEnabled
skip_if_context_24_tag:
skip_if_context_22_tag:
out "their Len = " $isTheirSyntaxLenEnabled " EndSymb " $isTheirSyntaxEndSymbolEnabled

; принимаеи решение о том какое кодирование использовать
$isOurSyntaxLenEnabled == 1 && $isTheirSyntaxLenEnabled == 1 if case_context_31_tag
$isOurSyntaxEndSymbolEnabled == 1 && $isTheirSyntaxEndSymbolEnabled == 1 if case_context_32_tag
out "err could not choose syntax"
raise_err
case_context_31_tag:
1 setto selectedSyntax
goto end_case_context_33_tag
case_context_32_tag:
2 setto selectedSyntax
goto end_case_context_33_tag
end_case_context_33_tag:
out "using syntax " $selectedSyntax

; запоминаем открывающие/закрывающие символы
contextFromConnectReq unbufferit ourOpenSymbol 1 ourCloseSymbol 1
contextFromConnectResp unbufferit theirOpenSymbol 1 theirCloseSymbol 1

; отправляем принятое решение на другое устройство
contextForConnectConf pack $ourOpenSymbol 1 $ourCloseSymbol 1 $selectedSyntax 1 3
dataToSend pack 3 1 $contextForConnectConf sizeof(contextFromConnectResp) sizeof(contextFromConnectResp)+1
userdata $dataToSend eventdown S_EXPEDITED_DATA.REQ

; завершаем этап соединения
quality $savedQuality context $contextForConnectConf sendup P_CONNECT.CONF
return

context_from_conf_tag:
out "received context from conf"
; распаковываем их значения и выбранный синтаксис
$dataReceived setto contextForConnectConf
contextForConnectConf unbufferit theirOpenSymbol 1 theirCloseSymbol 1 selectedSyntax 1
; распаковываем свои значения
contextFromConnectResp unbufferit ourOpenSymbol 1 ourCloseSymbol 1
return

original_data_tag:
out "received original data"
break
$selectedSyntax == 1 if len_tag
$selectedSyntax == 2 if end_symb_tag

return

len_tag:
out "decode len | reveresed to decode end symbol"
goto end_symb_tag
return

end_symb_tag:
out "decode end symbol"
dataReceived unbufferit dataType 1
out "dataType = " $dataType
$dataType == 1 if decode_string_tag
$dataType == 2 if send_as_is_tag
$dataType == 3 if send_as_is_tag
$dataType == 4 if send_as_is_tag
return

send_as_is_tag:
out "send as is"
userdata $dataReceived sendup P_EXPEDITED_DATA.IND
return

decode_string_tag:
dataReceived unbufferit dataType 1 strData sizeof(dataReceived)-1

; инициализируем переменные для результата
"" setto resultStrData
1 setto currentPos
sizeof(strData) setto strLength

replace_loop_tag:
; пока не достигли конца строки
$currentPos > $strLength if end_replace_tag

; копируем один символ из исходной строки
copy (strData, $currentPos, 1) setto tempChar

; проверяем, является ли символ открывающим / закрывающим
$tempChar == $unifiedOpenSymbol if replace_open_tag
$tempChar == $unifiedCloseSymbol if replace_close_tag

; если символ не нуждается в замене, добавляем его к результату
$resultStrData + $tempChar setto resultStrData
goto continue_replace_tag

replace_open_tag:
$resultStrData + $ourOpenSymbol setto resultStrData
goto continue_replace_tag

replace_close_tag:
$resultStrData + $ourCloseSymbol setto resultStrData
goto continue_replace_tag

continue_replace_tag:
; увеличиваем текущую позицию
$currentPos + 1 setto currentPos
goto replace_loop_tag

end_replace_tag:

out "Результат после декодирования  : " $resultStrData
dataToSend pack $dataType 1 $resultStrData sizeof(dataToSend) sizeof(dataToSend)+1
userdata $dataToSend sendup P_EXPEDITED_DATA.IND
return
